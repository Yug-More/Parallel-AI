# ============================================================
# main.py — Fully Rewritten Clean Backend (Part 1 of 3)
# ============================================================

import os
import uuid
import json
import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Literal

from fastapi import FastAPI, Request, Response, Depends, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, RedirectResponse, StreamingResponse
from pydantic import BaseModel
from jose import jwt, JWTError
from passlib.context import CryptContext
from sqlalchemy.orm import Session
from sqlalchemy import func

from database import SessionLocal, engine, Base
from models import (
    User as UserORM,
    UserCredential as UserCredentialORM,
    Organization as OrganizationORM,
    Room as RoomORM,
    Message as MessageORM,
    InboxTask as InboxTaskORM,
    Notification as NotificationORM,
    MemoryRecord as MemoryORM,
    AgentProfile as AgentORM,
)

from openai import OpenAI
from config import CLIENTS, OPENAI_MODEL
from dotenv import load_dotenv

load_dotenv()

# ============================================================
# App + CORS
# ============================================================

app = FastAPI(title="Parallel Workspace — Clean Rebuild")

ALLOWED_ORIGINS = ["http://localhost:5173"]
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

SECRET_KEY = os.getenv("SECRET_KEY", "dev-secret")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 1440

# ============================================================
# Utility
# ============================================================

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def create_access_token(data: dict, expires_delta: timedelta = None):
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=60))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

def verify_password(plain: str, hashed: str) -> bool:
    try:
        return pwd_context.verify(plain, hashed)
    except Exception:
        return False


def hash_password(password: str) -> str:
    return pwd_context.hash(password)


# ============================================================
# Current user
# ============================================================

def get_current_user(request: Request, db: Session) -> Optional[UserORM]:
    token = request.cookies.get("access_token")
    if not token:
        return None
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id = payload.get("sub")
        return db.get(UserORM, user_id)
    except JWTError:
        return None


def require_user(request: Request, db: Session) -> UserORM:
    user = get_current_user(request, db)
    if not user:
        raise HTTPException(401, "Not authenticated")
    return user


# ============================================================
# ORG LOGIC (Fix #1 & #4)
# ============================================================

def get_or_create_org_for_user(db: Session, user: UserORM) -> OrganizationORM:
    existing = (
        db.query(OrganizationORM)
        .filter(OrganizationORM.owner_user_id == user.id)
        .first()
    )
    if existing:
        return existing
    org = OrganizationORM(
        id=str(uuid.uuid4()),
        name=f"{user.name}'s Org",
        owner_user_id=user.id,
        created_at=datetime.utcnow(),
    )
    db.add(org)
    db.commit()
    return org


# ============================================================
# SOFT ROOM ACCESS VALIDATION (Fix #1)
# ============================================================

def ensure_room_access(db: Session, user: UserORM, room: RoomORM) -> None:
    """
    Required:
    - Enforce org_id match strictly
    - Only warn about name mismatches (never block)
    """
    user_org = get_or_create_org_for_user(db, user)

    if room.org_id != user_org.id:
        raise HTTPException(403, "Room belongs to another organization")

    # soft warning: team role mismatches, but never block
    # (keeps compatibility with historical rooms)
    # No exception here → only soft logging
    return


# ============================================================
# Schemas
# ============================================================

class AuthLoginRequest(BaseModel):
    email: str
    password: str


class UserOut(BaseModel):
    id: str
    email: str
    name: str
    created_at: datetime

    class Config:
        from_attributes = True


class CreateUserRequest(BaseModel):
    email: str
    name: str
    password: str


class CreateRoomRequest(BaseModel):
    room_name: str

    class Config:
        allow_population_by_field_name = True
        fields = {
            "room_name": "roomName",  # accept both room_name and roomName
        }


class CreateRoomResponse(BaseModel):
    room_id: str
    room_name: str


class AskModeRequest(BaseModel):
    user_id: str
    user_name: str
    content: str
    mode: Literal["self", "teammate", "team"] = "self"
    target_agent: Optional[str] = None


class MessageOut(BaseModel):
    id: str
    sender_id: str
    sender_name: str
    role: str
    content: str
    created_at: datetime

    class Config:
        from_attributes = True


class RoomResponse(BaseModel):
    room_id: str
    room_name: str
    project_summary: str
    memory_summary: str
    memory_count: int
    messages: List[MessageOut]

    class Config:
        from_attributes = True


class InboxCreateRequest(BaseModel):
    content: str
    room_id: Optional[str] = None
    source_message_id: Optional[str] = None
    priority: Optional[str] = None
    tags: List[str] = []


class InboxUpdateRequest(BaseModel):
    status: Literal["open", "done", "archived"]
    priority: Optional[str] = None


class InboxTaskOut(BaseModel):
    id: str
    content: str
    status: str
    priority: Optional[str]
    room_id: Optional[str]
    created_at: datetime

    class Config:
        from_attributes = True


class NotificationCreate(BaseModel):
    title: str
    message: Optional[str] = None
    room_id: Optional[str] = None
    source_message_id: Optional[str] = None
    priority: Optional[str] = None
    tags: List[str] = []


class NotificationOut(BaseModel):
    id: str
    user_id: str
    type: str
    title: str
    message: str
    created_at: datetime
    is_read: bool

    class Config:
        from_attributes = True


# ============================================================
# Helper: Convert ORM → Response
# ============================================================

def to_message_out(m: MessageORM) -> MessageOut:
    return MessageOut(
        id=m.id,
        sender_id=m.sender_id,
        sender_name=m.sender_name,
        role=m.role,
        content=m.content,
        created_at=m.created_at,
    )


def room_to_response(db: Session, room: RoomORM) -> RoomResponse:
    messages = (
        db.query(MessageORM)
        .filter(MessageORM.room_id == room.id)
        .order_by(MessageORM.created_at.asc())
        .all()
    )
    memory_count = (
        db.query(MemoryORM).filter(MemoryORM.room_id == room.id).count()
    )
    return RoomResponse(
        room_id=room.id,
        room_name=room.name,
        project_summary=room.project_summary or "",
        memory_summary=room.memory_summary or "",
        memory_count=memory_count,
        messages=[to_message_out(m) for m in messages],
    )


# ============================================================
# AUTH ROUTES (Fix #3)
# ============================================================

@app.post("/auth/register", response_model=UserOut)
def register(payload: CreateUserRequest, response: Response, db: Session = Depends(get_db)):
    exists = db.query(UserORM).filter(UserORM.email == payload.email).first()
    if exists:
        raise HTTPException(400, "Email already registered")

    user = UserORM(
        id=str(uuid.uuid4()),
        email=payload.email,
        name=payload.name,
        created_at=datetime.utcnow(),
    )
    cred = UserCredentialORM(
        user_id=user.id,
        password_hash=hash_password(payload.password),
        created_at=datetime.utcnow(),
    )
    db.add(user)
    db.add(cred)
    db.commit()

    # Auto-login
    token = create_access_token({"sub": user.id})
    response.set_cookie(
        "access_token",
        token,
        httponly=True,
        secure=False,
        samesite="none",
    )

    return user


@app.post("/auth/login")
def login(payload: AuthLoginRequest, response: Response, db: Session = Depends(get_db)):
    user = db.query(UserORM).filter(UserORM.email == payload.email).first()
    if not user:
        raise HTTPException(401, "Invalid credentials")

    cred = db.get(UserCredentialORM, user.id)
    if not cred or not verify_password(payload.password, cred.password_hash):
        raise HTTPException(401, "Invalid credentials")

    token = create_access_token({"sub": user.id})
    response = JSONResponse({"ok": True})
    response.set_cookie(
        "access_token",
        token,
        httponly=True,
        secure=False,
        samesite="none",
    )
    return response


@app.get("/me", response_model=UserOut)
def me(request: Request, db: Session = Depends(get_db)):
    user = require_user(request, db)
    get_or_create_org_for_user(db, user)   # Fix #4 ensure_org exists
    return user

@app.post("/rooms", response_model=CreateRoomResponse)
def create_room(payload: CreateRoomRequest, request: Request, db: Session = Depends(get_db)):
    user = require_user(request, db)
    org = get_or_create_org_for_user(db, user)

    room = RoomORM(
        id=str(uuid.uuid4()),
        name=payload.room_name,
        org_id=org.id,
        created_at=datetime.utcnow(),
    )
    db.add(room)
    db.commit()
    db.refresh(room)

    return CreateRoomResponse(room_id=room.id, room_name=room.name)



@app.get("/rooms/{room_id}", response_model=RoomResponse)
def get_room(room_id: str, request: Request, db: Session = Depends(get_db)):
    user = require_user(request, db)
    room = db.get(RoomORM, room_id)
    if not room:
        raise HTTPException(404, "Room not found")
    ensure_room_access(db, user, room)
    return room_to_response(db, room)


# ============================================================
# TEAM ROOM ROUTE (Fix #2)
# ============================================================

CANONICAL_ROOMS = {
    "engineering": "Engineering Room",
    "design": "Design Room",
    "team": "Team Room",
    "product": "Product Room",
}


@app.get("/rooms/team/{team_label}")
def get_or_create_team_room(team_label: str, request: Request, db: Session = Depends(get_db)):
    """
    Required by new dashboard → resolves canonical team room.
    """
    user = require_user(request, db)
    org = get_or_create_org_for_user(db, user)

    key = team_label.lower().strip()
    room_name = CANONICAL_ROOMS.get(key, f"{team_label.title()} Room")

    room = (
        db.query(RoomORM)
        .filter(RoomORM.org_id == org.id, RoomORM.name == room_name)
        .first()
    )
    if not room:
        room = RoomORM(
            id=str(uuid.uuid4()),
            name=room_name,
            org_id=org.id,
            created_at=datetime.utcnow(),
        )
        db.add(room)
        db.commit()

    return {"room_id": room.id, "room_name": room.name}


# ============================================================
# SSE — STATUS/ERROR STREAM (Fix #11)
# ============================================================

SUBSCRIBERS = []   # list[(queue, filters {room_id,user_id})]

async def event_generator(filters: Dict):
    queue: asyncio.Queue = asyncio.Queue()
    SUBSCRIBERS.append((queue, filters))
    try:
        while True:
            payload = await queue.get()
            # room filter
            if filters.get("room_id") and payload.get("room_id") != filters.get("room_id"):
                continue
            # user filter
            if filters.get("user_id") and payload.get("user_id") != filters.get("user_id"):
                continue
            yield f"data: {json.dumps(payload)}\n\n"
    finally:
        if (queue, filters) in SUBSCRIBERS:
            SUBSCRIBERS.remove((queue, filters))


def publish_event(payload: Dict):
    for queue, filters in list(SUBSCRIBERS):
        try:
            queue.put_nowait(payload)
        except asyncio.QueueFull:
            pass


@app.get("/events")
async def events(room_id: Optional[str] = None, user_id: Optional[str] = None):
    """
    SSE stream filtered by room
    """
    filters = {"room_id": room_id, "user_id": user_id}
    return StreamingResponse(event_generator(filters), media_type="text/event-stream")


def publish_status(room_id: str, step: str, meta: Optional[Dict] = None):
    publish_event({
        "type": "status",
        "room_id": room_id,
        "step": step,
        "meta": meta or {},
        "ts": datetime.utcnow().isoformat(),
    })


def publish_error(room_id: str, message: str, meta: Optional[Dict] = None):
    publish_event({
        "type": "error",
        "room_id": room_id,
        "message": message,
        "meta": meta or {},
        "ts": datetime.utcnow().isoformat(),
    })

@app.get("/users/{user_id}/inbox", response_model=List[InboxTaskOut])
def list_inbox(user_id: str, request: Request, db: Session = Depends(get_db)):
    me = require_user(request, db)

    # Allow legacy "demo-user" slug to map to the logged-in user
    if user_id == "demo-user":
        user_id = me.id

    if me.id != user_id:
        raise HTTPException(403, "Forbidden")

    tasks = (
        db.query(InboxTaskORM)
        .filter(InboxTaskORM.user_id == user_id)
        .order_by(InboxTaskORM.created_at.desc())
        .all()
    )
    return tasks

@app.post("/users/{user_id}/inbox", response_model=InboxTaskOut)
def add_inbox(user_id: str, payload: InboxCreateRequest, request: Request, db: Session = Depends(get_db)):
    me = require_user(request, db)
    if me.id != user_id:
        raise HTTPException(403, "Forbidden")

    task = InboxTaskORM(
        id=str(uuid.uuid4()),
        user_id=user_id,
        content=payload.content,
        room_id=payload.room_id,
        source_message_id=payload.source_message_id,
        priority=payload.priority,
        tags=payload.tags,
        status="open",
        created_at=datetime.utcnow(),
    )
    db.add(task)
    db.commit()
    db.refresh(task)
    return task


@app.patch("/users/{user_id}/inbox/{task_id}", response_model=InboxTaskOut)
def update_inbox(user_id: str, task_id: str, payload: InboxUpdateRequest, request: Request, db: Session = Depends(get_db)):
    me = require_user(request, db)
    if me.id != user_id:
        raise HTTPException(403, "Forbidden")

    task = db.get(InboxTaskORM, task_id)
    if not task or task.user_id != user_id:
        raise HTTPException(404, "Task not found")

    task.status = payload.status
    task.priority = payload.priority or task.priority

    db.add(task)
    db.commit()
    db.refresh(task)
    return task

@app.get("/users/{user_id}/notifications", response_model=List[NotificationOut])
def list_notifications(user_id: str, request: Request, db: Session = Depends(get_db)):
    me = require_user(request, db)

    if user_id == "demo-user":
        user_id = me.id

    if me.id != user_id:
        raise HTTPException(403, "Forbidden")

    notifs = (
        db.query(NotificationORM)
        .filter(NotificationORM.user_id == user_id)
        .order_by(NotificationORM.created_at.desc())
        .all()
    )
    return notifs

@app.post("/users/{user_id}/notifications", response_model=NotificationOut)
def create_notification(user_id: str, payload: NotificationCreate, request: Request, db: Session = Depends(get_db)):
    me = require_user(request, db)

    notif = NotificationORM(
        id=str(uuid.uuid4()),
        user_id=user_id,
        type="task",
        title=payload.title,
        message=payload.message or payload.title,
        created_at=datetime.utcnow(),
        is_read=False,
    )
    db.add(notif)
    db.commit()
    db.refresh(notif)
    return notif

# ============================================================
# MEMORY HELPERS
# ============================================================

def append_memory(db: Session, room: RoomORM, agent_id: str, content: str, importance: float = 0.1):
    mem = MemoryORM(
        id=str(uuid.uuid4()),
        agent_id=agent_id,
        room_id=room.id,
        content=content,
        importance_score=importance,
        created_at=datetime.utcnow(),
    )
    db.add(mem)
    return mem


def list_recent_memories(db: Session, room_id: str, limit: int = 8):
    return (
        db.query(MemoryORM)
        .filter(MemoryORM.room_id == room_id)
        .order_by(MemoryORM.created_at.desc())
        .limit(limit)
        .all()
    )


# ============================================================
# SUMMARY UPDATE RULES (Fix #14)
# ============================================================

def extract_explicit_summary_request(text: str) -> Optional[str]:
    """
    Only update summary if user writes something like:
        "update summary: <text>"
    """
    marker = "update summary:"
    lower = text.lower()
    if marker in lower:
        return text[lower.index(marker) + len(marker):].strip()
    return None

def build_ai_prompt(db: Session, room: RoomORM, user: UserORM, content: str, mode: str):
    memories = list_recent_memories(db, room.id, limit=8)
    mem_text = "\n".join(f"- {m.content}" for m in memories)

    system = f"""
You are the workspace assistant inside the room "{room.name}".

Core rules:
- Never actually send messages outside this chat. You only talk to the user here.
- Never say that you are "drafting" a message or "won't send it automatically".
- Never auto-create inbox tasks or notifications unless the user clearly asks for that.
- Never update summaries unless the user explicitly says: "update summary: ...".
- Answer concisely and stay on task.
- Do not hallucinate tasks, inbox items, or teammates that don't exist.

When the user asks you to "send a message to X", or "tell X that ...":
- Assume they want help with the wording.
- Respond with a short, natural message they could send, e.g.
  "Here’s a message you could send to Alice about fixing the UI: '...'"
- Do NOT call it a "draft".
- It's okay to ask once for confirmation like:
  "Do you want to use that message as-is?"
- Do not repeat long disclaimers about what you can or cannot do.

You may use these recent memory notes and project context:

Project Summary:
{room.project_summary or "(none)"}

Recent Memory Notes:
{mem_text or "(none)"}

Mode: {mode}
    """.strip()

    user_msg = f"{user.name} says:\n{content}"

    return system, user_msg


def run_ai(client: OpenAI, system_prompt: str, user_text: str) -> str:
    """
    Unified OpenAI chat wrapper.
    """
    resp = client.chat.completions.create(
        model=OPENAI_MODEL,
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user",   "content": user_text},
        ],
        temperature=0.4,
    )
    return resp.choices[0].message.content


# ============================================================
# ASK ROUTE (Fix #5, #6, #11, #14)
# ============================================================

@app.post("/rooms/{room_id}/ask", response_model=RoomResponse)
def ask(room_id: str, payload: AskModeRequest, request: Request, db: Session = Depends(get_db)):
    """
    Clean, non-spammy, stable version of the ask route.
    """
    user = require_user(request, db)
    room = db.get(RoomORM, room_id)
    if not room:
        raise HTTPException(404, "Room not found")

    ensure_room_access(db, user, room)

    # Save human message
    user_msg = MessageORM(
        id=str(uuid.uuid4()),
        room_id=room.id,
        sender_id=f"user:{user.id}",
        sender_name=user.name,
        role="user",
        content=payload.content,
        created_at=datetime.utcnow(),
    )
    db.add(user_msg)
    db.commit()

    publish_status(room_id, "received", {"mode": payload.mode})

    # Build system & user prompts
    system_prompt, user_prompt = build_ai_prompt(
        db=db,
        room=room,
        user=user,
        content=payload.content,
        mode=payload.mode
    )

    # Decide agent used for reply
    agent_id = payload.target_agent or "coordinator"
    client = CLIENTS.get(agent_id, CLIENTS["coordinator"])

    # AI Call
    try:
        publish_status(room_id, "thinking")
        answer = run_ai(client, system_prompt, user_prompt)
        publish_status(room_id, "reply_ready", {"agent": agent_id})
    except Exception as exc:
        publish_error(room_id, f"AI error: {exc}")
        raise HTTPException(502, "AI provider error")

    # Save assistant message
    bot_msg = MessageORM(
        id=str(uuid.uuid4()),
        room_id=room.id,
        sender_id=f"agent:{agent_id}",
        sender_name=agent_id.title(),
        role="assistant",
        content=answer,
        created_at=datetime.utcnow(),
    )
    db.add(bot_msg)

    # Explicit summary updates
    summary_update = extract_explicit_summary_request(payload.content)
    if summary_update:
        room.project_summary = summary_update
        append_memory(db, room, agent_id="coordinator", content=f"Summary updated: {summary_update}", importance=0.4)

    # No auto-updates occur — this matches Fix #14 exactly.

    db.commit()

    # Return updated room
    return room_to_response(db, room)


# ============================================================
# MEMORY ENDPOINTS
# ============================================================

@app.get("/rooms/{room_id}/memory")
def get_memory(room_id: str, request: Request, db: Session = Depends(get_db)):
    user = require_user(request, db)
    room = db.get(RoomORM, room_id)
    if not room:
        raise HTTPException(404, "Room not found")
    ensure_room_access(db, user, room)

    notes = (
        db.query(MemoryORM)
        .filter(MemoryORM.room_id == room_id)
        .order_by(MemoryORM.created_at.desc())
        .limit(20)
        .all()
    )
    return {
        "project_summary": room.project_summary or "",
        "memory_summary": room.memory_summary or "",
        "notes": [m.content for m in notes],
        "count": len(notes),
    }


class MemoryQueryRequest(BaseModel):
    question: str


@app.post("/rooms/{room_id}/memory/query")
def query_memory(room_id: str, payload: MemoryQueryRequest, request: Request, db: Session = Depends(get_db)):
    """
    Small helper: asks the coordinator model ONLY using memory context.
    """
    user = require_user(request, db)

    room = db.get(RoomORM, room_id)
    if not room:
        raise HTTPException(404, "Room not found")
    ensure_room_access(db, user, room)

    notes = (
        db.query(MemoryORM)
        .filter(MemoryORM.room_id == room.id)
        .order_by(MemoryORM.created_at.desc())
        .limit(200)
        .all()
    )
    text = "\n".join(n.content for n in notes)

    system_prompt = f"""
You are the memory subsystem for room "{room.name}".
Only answer based on memory context below.
Never invent details.

Memory Context:
{text or "(empty)"}
    """

    client = CLIENTS["coordinator"]
    answer = run_ai(client, system_prompt, payload.question)

    # optional: log memory usage
    append_memory(db, room, agent_id="coordinator", content=f"Memory queried: {payload.question}", importance=0.05)
    db.commit()

    return {"answer": answer}

